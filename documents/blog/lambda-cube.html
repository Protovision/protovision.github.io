<article>
	<header class="top-border">
		<h2>Lambda Cube</h2>
		<time datetime="2023-05-08">2023-05-08</time>
	</header>
	<p>
		My brief notes on lambda cube. A programming language can be formulated as a 
		calculus of terms and types. Assuming these notation letters:
	</p>
	<ul>
		<li>Kinds: K, L, M, *</li>
		<li>Types: T, U, V</li>
		<li>Type variables: t, u, v</li>
		<li>Terms: e, f, g</li>
		<li>Term variables: x, y, z</li>
	</ul>
	<p>
		Here are the ways that types and terms may depend on each other:
	</p>
	<figure>
		<table class="centered centered-text">
			<thead class="shaded">
				<tr>
					<th>Dimension</th>
					<th>Entity</th>
					<th>Type</th>
					<th>Term</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>0</td>
					<td>Function</td>
					<td>T &rarr; U</td>
					<td>&lambda; x : T . e</td>
				</tr>
				<tr>
					<td>1</td>
					<td>Dependent function</td>
					<td>x : T &rarr; U</td>
					<td>&lambda; x : T . e</td>
				</tr>
				<tr>
					<td>1</td>
					<td>Dependent pair</td>
					<td>x : T &wedge; U</td>
					<td>x : T , e</td>
				</tr>
				<tr>
					<td>2</td>
					<td>Polymorphic function</td>
					<td>&forall; t : K . T</td>
					<td>&lambda; t : K . e</td>
				</tr>
				<tr>
					<td>2</td>
					<td>Polymorphic pair</td>
					<td>&exist; t : K . T</td>
					<td>t : K , e</td>
				</tr>
				<tr>
					<td>3</td>
					<td>Type constructor</td>
					<td>K &rarr; L</td>
					<td>&lambda; t : K . T</td>
				</tr>
			</tbody>
		</table>
	</figure>
	<dl>
		<dt>Dependent pair</dt>
		<dd>
			A pair of terms where the second term's type depends on the 
			first term
		</dd>
		<dt>Dependent function</dt>
		<dd>
			A function from term to term where the type of the output
			term depends on the input term
		</dd>
		<dt>Polymorphic pair</dt>
		<dd>
			A pair of a type and a term where the type of the term in the 
			pair depends on the type in the pair
		</dd>
		<dt>Polymorphic function</dt>
		<dd>
			A function from type to term where the type of the output term
			depends on the input type
		</dd>
		<dt>Type constructor</dt>
		<dd>A function from type to type</dd>
	</dl>
	<p>
		Where a concrete type is defined as both a proper type and a type 
		constant, the practical restrictions for a programming language 
		approaching lambda cube are:
	<ul>
		<li>
			A (dependent) function's term variable shall always be of a concrete type
		</li>
		<li>
			A polymorphic function's type variable shall always be a concrete type
		</li>
		<li>
			A polymorphic pair's type variable shall always be a concrete type whose 
			structure does not vary for all concrete types, additionally the 
			type-dependent term in that pair shall itself be a pair that stores a 
			term of that type variable
		</li>
	</ul>
	<p>
		With these restrictions, and C and D being concrete types, the table 
		is refined to:
	</p>
	<figure>
		<table class="centered centered-text">
			<thead class="shaded">
				<tr>
					<th>Dimension</th>
					<th>Entity</th>
					<th>Type</th>
					<th>Term</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>0</td>
					<td>Function</td>
					<td>C &rarr; D</td>
					<td>&lambda; x : C . e</td>
				</tr>
				<tr>
					<td>1</td>
					<td>Dependent function</td>
					<td>x : C &rarr; D</td>
					<td>&lambda; x : C . e</td>
				</tr>
				<tr>
					<td>1</td>
					<td>Dependent pair</td>
					<td>x : C &wedge; D</td>
					<td>x : C , e</td>
				</tr>
				<tr>
					<td>2</td>
					<td>Polymorphic function</td>
					<td>&forall; t : * . C</td>
					<td>&lambda; t : * . e</td>
				</tr>
				<tr>
					<td>2</td>
					<td>Polymorphic pair</td>
					<td>&exist; t : * . t &wedge; C</td>
					<td>t : * , t , e</td>
				</tr>
				<tr>
					<td>3</td>
					<td>Type constructor</td>
					<td>K &rarr; L</td>
					<td>&lambda; t : K . T</td>
				</tr>
			</tbody>
		</table>
	</figure>
	<p>
		Existing programming languages do not precisely match these dimensions of 
		the cube but they roughly do so by providing the following common features
		which relate to one or more dimensions:
	</p>
	<ul>
		<li>Generic functions &rarr; Polymorphic functions</li>
		<li>Dynamic dispatch &rarr; Polymorphic pairs</li>
		<li>Generic types &rarr; Type constructors</li>
	</ul>
	<p>
		Most languages except the academic ones do not really support dependent 
		types.
	</p>
</article>
