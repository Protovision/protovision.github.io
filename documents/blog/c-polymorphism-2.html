<article>
	<header>
		<h2>C Polymorphism II</h2>
		by Mark Swoope
		<br>
		<time datetime="2024-08-05">2024-08-05</time>
	</header>
	<p>The previous article demonstrated polymorphism in C in the form of type constructors and polymorphic functions: accomplished with function macros that generate C code from type names.</p>
	<p>Here we explore C polymorphism with abstract data types which are data types that store functions for operating on an unknown data type. An abstract data type provides a stable interface for different implementatations to initialize.</p>
	<p>The abstract data type is formally expressed as the existential type &exist;T.K(T): it is a pair consisting of the type variable T, bound to some proper type, and the type constructed from applying K to T.</p>
	<p>Consider the example of a reader: an abstract type for reading one byte at a time: &exist;T.T&wedge;T&rarr;int&wedge;T&rarr;void. This reader type stores an instance of some unknown type T, together with a function for reading a byte from it, and another function for closing it.</p>
	<p>Here are two ways to implement this in C:</p>
	<figure>
		<figcaption>&ldquo;Fat pointer&rdquo; implementation</figcaption>
		<pre class="no-margin code padded">struct&nbsp;byte_reader_interface{<br>&nbsp;&nbsp;int((*&nbsp;read)(void&nbsp;*));<br>&nbsp;&nbsp;void((*&nbsp;close)(void&nbsp;*));<br>};<br>struct&nbsp;byte_reader{<br>&nbsp;&nbsp;void(*&nbsp;data);<br>&nbsp;&nbsp;struct&nbsp;byte_reader_interface&nbsp;const(*&nbsp;interface);<br>};</pre>
	</figure>
	<figure>
		<figcaption>Fat pointer implementation diagram</figcaption>
		<pre class="no-margin code padded">+-------------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-----+<br>|&nbsp;byte_reader&nbsp;|&nbsp;&nbsp;+-&gt;&nbsp;|&nbsp;...&nbsp;|<br>+-------------+&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;+-----+<br>|&nbsp;data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;-+&nbsp;&nbsp;&nbsp;+-----------------------+<br>|&nbsp;interface&nbsp;&nbsp;&nbsp;|&nbsp;---&gt;&nbsp;|&nbsp;byte_reader_interface&nbsp;|<br>+-------------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-----------------------+<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;read&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;close&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-----------------------+</pre>
	</figure>
	<figure>
		<figcaption>&ldquo;Thin pointer&rdquo; implementation</figcaption>
		<pre class="no-margin code padded">struct&nbsp;byte_reader_interface;<br>typedef&nbsp;struct&nbsp;byte_reader_interface&nbsp;const(*&nbsp;*&nbsp;byte_reader);<br>struct&nbsp;byte_reader_interface{<br>&nbsp;&nbsp;int((*&nbsp;read)(void&nbsp;*));<br>&nbsp;&nbsp;void((*&nbsp;close)(void&nbsp;*));<br>};</pre>
	</figure>
	<figure>
		<figcaption>Thin pointer implementation diagram</figcaption>
		<pre class="no-margin code padded">+-------------+&nbsp;&nbsp;&nbsp;&nbsp;+-----------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-----------------------+<br>|&nbsp;byte_reader&nbsp;|&nbsp;-&gt;&nbsp;|&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;+-&gt;&nbsp;|&nbsp;byte_reader_interface&nbsp;|<br>+-------------+&nbsp;&nbsp;&nbsp;&nbsp;+-----------+&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;+-----------------------+<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;interface&nbsp;|&nbsp;-+&nbsp;&nbsp;&nbsp;|&nbsp;read&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;close&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-----------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-----------------------+<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</pre>
	</figure>
	<p>In both implementations, the interface functions accept <code>void *</code> in place of any instance of the type bound to the type variable. For a fat pointer fp, it's data is accessible as <code>(fp) . data</code>; for a thin pointer tp, it's data is accessible as <code>(void *)(tp + 1)</code>.</p>
	<p>The main advantage of thin pointers is that the abstract term can be shared using a single pointer, whereas fat pointers occupy 2 pointers. Because of this, thin pointers can be used with atomic operations while fat pointers cannot.</p>
	<p>The main advantage of fat pointers is that it's data can exist independently, and possibly prior, to the assignment of an interface to it; with thin pointers, the interface and data share the same lifetime. Fat pointers can also eliminate dynamic storage allocation in cases where it's hidden data is small enough to be embedded directly in the data pointer.</p>
	<p>Let's now consider how these implementations scale when translated from existential types containing multiple type variables.</p>
	<p>Here is a type that can express a pipe, a unidirectional communication channel. For the sake of the example, I include a function for closing both ends of the pipe, simultaneously: &exist;T.&exist;U.T&wedge;T&rarr;int&wedge;U&wedge;U&rarr;int&rarr;int&wedge;T&rarr;U&rarr;void</p>
	<p>If it were not for the last function, this type could have been implemented as a pair of abstract fat pointers or a pair of abstract thin pointers.</p>
	<p>Unless we want to store an extra void-pointer into the fat pointer for each additional type variable, we can scale the fat pointer with another layer of indirection.</p>
	<figure>
		<figcaption>Fat pointer diagram for multiple type variables</figcaption>
		<pre class="no-margin code padded">+-----------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+------------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-----+<br>|&nbsp;pipe&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;+-&gt;&nbsp;|&nbsp;void&nbsp;*&nbsp;[2]&nbsp;|&nbsp;&nbsp;+-&gt;&nbsp;|&nbsp;...&nbsp;|<br>+-----------+&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;+------------+&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;+-----+<br>|&nbsp;data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;-+&nbsp;&nbsp;&nbsp;|&nbsp;[0]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;-+&nbsp;&nbsp;&nbsp;+-----+<br>|&nbsp;interface&nbsp;|&nbsp;-+&nbsp;&nbsp;&nbsp;|&nbsp;[1]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;---&gt;&nbsp;|&nbsp;...&nbsp;|<br>+-----------+&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;+------------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-----+<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;+----------------+<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-&gt;&nbsp;|&nbsp;pipe_interface&nbsp;|<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+----------------+<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;read&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;write&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;close&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+----------------+</pre>
	</figure>
	<figure>
		<figcaption>Fat pointer code for multiple type variables</figcaption>
		<pre class="no-margin code padded">struct&nbsp;pipe_interface{<br>&nbsp;&nbsp;int((*&nbsp;read)(void&nbsp;*));<br>&nbsp;&nbsp;int((*&nbsp;write)(void&nbsp;*&nbsp;,&nbsp;int));<br>&nbsp;&nbsp;void((*&nbsp;close)(void&nbsp;*&nbsp;,&nbsp;void&nbsp;*));<br>};<br>struct&nbsp;pipe{<br>&nbsp;&nbsp;void&nbsp;*((*&nbsp;data)[2]);<br>&nbsp;&nbsp;struct&nbsp;pipe_interface&nbsp;const(*&nbsp;interface);<br>};</pre>
	</figure>
	<figure>
		<figcaption>Thin pointer diagram for multiple type variables</figcaption>
		<pre class="no-margin code padded">+------+&nbsp;&nbsp;&nbsp;&nbsp;+-----------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+----------------+<br>|&nbsp;pipe&nbsp;|&nbsp;-&gt;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;+---&gt;&nbsp;|&nbsp;pipe_interface&nbsp;|<br>+------+&nbsp;&nbsp;&nbsp;&nbsp;+-----------+&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+----------------+<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;interface&nbsp;|&nbsp;-+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;read&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;data[0]&nbsp;&nbsp;&nbsp;|&nbsp;---+&nbsp;&nbsp;&nbsp;|&nbsp;write&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;data[1]&nbsp;&nbsp;&nbsp;|&nbsp;-+&nbsp;|&nbsp;&nbsp;&nbsp;|&nbsp;close&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-----------+&nbsp;&nbsp;|&nbsp;|&nbsp;&nbsp;&nbsp;+----------------+<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;|&nbsp;&nbsp;&nbsp;+-----+<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;+-&gt;&nbsp;|&nbsp;...&nbsp;|<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-----+<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-----+<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+---&gt;&nbsp;|&nbsp;...&nbsp;|<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+-----+</pre>
	</figure>
	<figure>
		<figcaption>Thin pointer code for multiple type variables</figcaption>
		<pre class="no-margin code padded">struct&nbsp;pipe_interface{<br>&nbsp;&nbsp;int((*&nbsp;read)(void&nbsp;*));<br>&nbsp;&nbsp;int((*&nbsp;write)(void&nbsp;*&nbsp;,&nbsp;int));<br>&nbsp;&nbsp;void((*&nbsp;close)(void&nbsp;*&nbsp;,&nbsp;void&nbsp;*));<br>};<br>typedef&nbsp;struct{<br>&nbsp;&nbsp;struct&nbsp;pipe_interface&nbsp;const(*&nbsp;interface);<br>&nbsp;&nbsp;void&nbsp;*(data[2]);<br>}(*&nbsp;pipe);</pre>
	</figure>
	<p>When multiple type variables are involved, the thin pointer implementation now gains one of the advantages that was previously unique to the fat pointer implementation: the independence of the data from the interface. The fat pointer implementation also loses the advantage of potentially avoiding dynamic storage that it had using small data optimization when there was only 1 type variable.</p>
	<p>Fat pointers can still use small data optimization after the initial dynamic storage allocation of the void-pointer array; each instance of the value of a type variable can be stored directly in it's corresponding void-pointer if small enough, but thin pointers can also apply this same optimization to it's own void-pointer array now.</p>
	<p>The only conceivable advantage of fat pointers now is having 1 fewer indirections to the interface functions, but this can be waived away by caching the results of these indirections.</p>
	<p>Summary: Thin pointers scale better than fat pointers for abstract data types involving more than 1 hidden type. A thin pointer fits within a register and qualifies for atomic operations. Fat pointers can enclose prior existing heap data without relocating it. In the specific case involving 1 hidden type of small size, a fat pointer can avoid using dynamic storage. 
</article>

