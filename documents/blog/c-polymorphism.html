<article>
	<header class="top-border">
		<h2>C Polymorphism</h2>
		by Mark Swoope<br>
		<time datetime="2024-07-30">2024-07-30</time>
	</header>
	<p>The C language has advantages in being fast, portable, and small. It's disadvantages include the lack of performing universal quantification and existential quantification, which to be fair: no mainstream language really supports beyond the depended type being a constant.</p>
	<p>Universal quantification is &forall;T.F(T): abstractly a function that transforms anything. This most commonly takes the form of what is known as a polymorphic function, whose definition performs computation in terms of an arbitrary type argument.</p>
	<p>To support universal quantification over constant, proper types; function-macros can be used. Consider the example for three-way comparison:</p>
	<pre class="no-margin padded code">#&nbsp;define&nbsp;text_raw_prefix(a&nbsp;,&nbsp;b)&nbsp;a&nbsp;##&nbsp;__&nbsp;##&nbsp;b<br>#&nbsp;define&nbsp;text_prefix(a&nbsp;,&nbsp;b)&nbsp;text_raw_prefix(a&nbsp;,&nbsp;b)<br>#&nbsp;define&nbsp;polymorphic_compare(t)&nbsp;text_prefix(polymorphic_compare&nbsp;,&nbsp;t)<br>#&nbsp;define&nbsp;define_polymorphic_compare(t)&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;int(polymorphic_compare(t)(t&nbsp;const(a)&nbsp;,&nbsp;t&nbsp;const(b))){\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(a&nbsp;&lt;&nbsp;b&nbsp;?&nbsp;-&nbsp;1&nbsp;:&nbsp;a&nbsp;&gt;&nbsp;b&nbsp;?&nbsp;1&nbsp;:&nbsp;0);\<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>define_polymorphic_compare(char);<br>define_polymorphic_compare(int);<br>define_polymorphic_compare(double);</pre>
	<p>This preprocesses to:</p>
	<pre class="no-margin padded code">int(polymorphic_compare__char(char&nbsp;const(a)&nbsp;,&nbsp;char&nbsp;const(b))){&nbsp;return(a&nbsp;&lt;&nbsp;b&nbsp;?&nbsp;-&nbsp;1&nbsp;:&nbsp;a&nbsp;&gt;&nbsp;b&nbsp;?&nbsp;1&nbsp;:&nbsp;0);&nbsp;};<br>int(polymorphic_compare__int(int&nbsp;const(a)&nbsp;,&nbsp;int&nbsp;const(b))){&nbsp;return(a&nbsp;&lt;&nbsp;b&nbsp;?&nbsp;-&nbsp;1&nbsp;:&nbsp;a&nbsp;&gt;&nbsp;b&nbsp;?&nbsp;1&nbsp;:&nbsp;0);&nbsp;};<br>int(polymorphic_compare__double(double&nbsp;const(a)&nbsp;,&nbsp;double&nbsp;const(b))){&nbsp;return(a&nbsp;&lt;&nbsp;b&nbsp;?&nbsp;-&nbsp;1&nbsp;:&nbsp;a&nbsp;&gt;&nbsp;b&nbsp;?&nbsp;1&nbsp;:&nbsp;0);&nbsp;};</pre>
	<p>Our function-macro <code>define_polymorphic_compare</code> defines a new function that is named from the expansion of <code>polymorphic_compare(t)</code>. The macro generates the function name by concatenating the token <code>polymorphic_compare</code> with whatever <code>t</code> expands to. Because of this, the function-macro only works for single-identifier named types; unnamed types must be named through type definitions before being used for polymorphism this way.</p>
	<p>During the token concatentation for function name generation, the function-macro <code>text_prefix</code> is required to forward it's arguments to <code>text_raw_prefix</code> for an additional expansion since the token pasting operator <code>##</code> inhibits expansion of it's operands.</p>
	<p>Unlike in modern languages, monomorphization is not automatic. Each new instance of <code>polymorphic_compare</code> requires a unique expansion of <code>define_polymorphic_compare</code>; and the one-definition rule disallows the same function to be defined more than once.</p>
	<p>The solution to this is to place each instantiation into it's own header file with include guards. Additionally, the header file should itself include any instantiation header files that the polymorphic definition depends on, especially instantiations of other polymorphic functions/types that instantiated by the same type argument.</p>
	<p>Often times it is desirable to provide specific instantiations for a limited set of type arguments while providing a generic instantiation for all other types (if at all).</p>
	<p>Let's extend the example by specializing <code>polymorphic_compare(int)</code> to simply subtract it's arguments while keeping the other instantiations the same.</p>
	<pre class="no-margin padded code">#&nbsp;define&nbsp;text_raw_prefix(a&nbsp;,&nbsp;b)&nbsp;a&nbsp;##&nbsp;__&nbsp;##&nbsp;b<br>#&nbsp;define&nbsp;text_prefix(a&nbsp;,&nbsp;b)&nbsp;text_raw_prefix(a&nbsp;,&nbsp;b)<br>#&nbsp;define&nbsp;text_if(x)&nbsp;text_prefix(text_if&nbsp;,&nbsp;x)<br>#&nbsp;define&nbsp;text_if__1(...)&nbsp;__VA_ARGS__&nbsp;text_else__1<br>#&nbsp;define&nbsp;text_else__1(...)<br>#&nbsp;define&nbsp;text_if__0(...)&nbsp;text_else__0<br>#&nbsp;define&nbsp;text_else__0(...)&nbsp;__VA_ARGS__<br>#&nbsp;define&nbsp;text_second(a&nbsp;,&nbsp;b&nbsp;,&nbsp;...)&nbsp;b<br>#&nbsp;define&nbsp;text_prove(...)&nbsp;text_second(__VA_ARGS__&nbsp;,&nbsp;0)<br>#&nbsp;define&nbsp;text_proof()&nbsp;0&nbsp;,&nbsp;1<br>#&nbsp;define&nbsp;text_equals_int(x)&nbsp;text_prove(text_prefix(text_equals_int&nbsp;,&nbsp;x))<br>#&nbsp;define&nbsp;text_equals_int__int&nbsp;text_proof()<br>#&nbsp;define&nbsp;polymorphic_compare(t)&nbsp;text_prefix(polymorphic_compare&nbsp;,&nbsp;t)<br>#&nbsp;define&nbsp;define_polymorphic_compare(t)&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;int(polymorphic_compare(t)(t&nbsp;const(a)&nbsp;,&nbsp;t&nbsp;const(b))){\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text_if(text_equals_int(t))(\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;-&nbsp;b\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)(\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;&lt;&nbsp;b&nbsp;?&nbsp;-&nbsp;1&nbsp;:&nbsp;a&nbsp;&gt;&nbsp;b&nbsp;?&nbsp;1&nbsp;:&nbsp;0\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);\<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>define_polymorphic_compare(char);<br>define_polymorphic_compare(int);<br>define_polymorphic_compare(double);</pre>
	<p>The result:</p>
	<pre class="no-margin padded code">int(polymorphic_compare__char(char&nbsp;const(a)&nbsp;,&nbsp;char&nbsp;const(b))){&nbsp;return(&nbsp;a&nbsp;&lt;&nbsp;b&nbsp;?&nbsp;-&nbsp;1&nbsp;:&nbsp;a&nbsp;&gt;&nbsp;b&nbsp;?&nbsp;1&nbsp;:&nbsp;0&nbsp;);&nbsp;};<br>int(polymorphic_compare__int(int&nbsp;const(a)&nbsp;,&nbsp;int&nbsp;const(b))){&nbsp;return(&nbsp;a&nbsp;-&nbsp;b&nbsp;);&nbsp;};<br>int(polymorphic_compare__double(double&nbsp;const(a)&nbsp;,&nbsp;double&nbsp;const(b))){&nbsp;return(&nbsp;a&nbsp;&lt;&nbsp;b&nbsp;?&nbsp;-&nbsp;1&nbsp;:&nbsp;a&nbsp;&gt;&nbsp;b&nbsp;?&nbsp;1&nbsp;:&nbsp;0&nbsp;);&nbsp;};</pre>
	<p>A metaprogramming construct <code>text_if</code> is introduced which expands to the text from it's 2nd application or 3rd application depending on it's 1st application expanding to 1 or 0.</p>
	<p>The function-macro <code>text_equals_int</code> expands to 1 if it's argument is <code>int</code>, and 0 otherwise; it depends on <code>text_prove</code> and <code>text_proof</code>: the former being a function-macro that expands to 1 only if the expansion of <code>text_proof</code> is it's argument.</p>
	<p>These utilities allow us to statically match against any specific token (but we can never compare two arbitrary tokens).</p>
	<p>Another special caveat of all this is that type matching here is nominal, therefore something like <code>size_t</code> will not match against <code>uint32_t</code> even if they are structurally equal on your platform. To get around this, type aliasing needs to be defined through object-macros rather than type definitions.</p>
	<p>These same methods can be used for creating type constructors in C: mappings from types to types. This can be how an array container, supporting both dynamic and fixed lengths, can be defined:</p>
	<pre class="no-margin padded code">#&nbsp;define&nbsp;text_equals_auto(x)&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;text_prove(text_prefix(text_equals_auto&nbsp;,&nbsp;x))<br>#&nbsp;define&nbsp;text_equals_auto__auto&nbsp;text_proof()<br>#&nbsp;define&nbsp;container_array(t&nbsp;,&nbsp;n)&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;text_prefix(container_array&nbsp;,&nbsp;text_prefix(t&nbsp;,&nbsp;n))<br>#&nbsp;define&nbsp;define_container_array(t&nbsp;,&nbsp;n)&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;struct{\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;text_if(text_equals_auto(n))(\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t(size);\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t(data[])\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)(\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t(data[n])\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);\<br>&nbsp;&nbsp;&nbsp;&nbsp;}(container_array(t&nbsp;,&nbsp;n))<br>define_container_array(char&nbsp;,&nbsp;auto);<br>define_container_array(float&nbsp;,&nbsp;3);</pre>
	<p>Which results in:</p>
	<pre class="no-margin padded code">typedef&nbsp;struct{&nbsp;size_t(size);&nbsp;char(data[])&nbsp;;&nbsp;}(container_array__char__auto);<br>typedef&nbsp;struct{&nbsp;float(data[3]);&nbsp;}(container_array__float__3);</pre>
	<p>The keyword <code>auto</code> is chosen to indicate a dynamic array which can only exist in dynamic storage, any other value for the 2nd argument is assumed to be an integer constant for it's fixed length.</p>
	<p>Here's an example for an <em>either</em> kind, the type constructor that stores and tracks itself as one out of two possible types at a time.</p>
	<pre class="no-margin padded code">#&nbsp;include&quot;text.h&quot;<br>#&nbsp;include&lt;stdio.h&gt;<br>#&nbsp;define&nbsp;either(t&nbsp;,&nbsp;u)&nbsp;text_prefix(either&nbsp;,&nbsp;text_prefix(t&nbsp;,&nbsp;u))<br>#&nbsp;define&nbsp;define_either(t&nbsp;,&nbsp;u)&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;struct{\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;const(*&nbsp;type);\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;union{\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t(text_prefix(as&nbsp;,&nbsp;t));\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u(text_prefix(as&nbsp;,&nbsp;u));\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}(value);\<br>&nbsp;&nbsp;&nbsp;&nbsp;}(either(t&nbsp;,&nbsp;u))<br>#&nbsp;define&nbsp;either_value(t&nbsp;,&nbsp;...)&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;{\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp;type&nbsp;=&nbsp;text_string(t)\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;.&nbsp;value&nbsp;=&nbsp;{\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp;text_prefix(as&nbsp;,&nbsp;t)&nbsp;=&nbsp;__VA_ARGS__\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>#&nbsp;define&nbsp;either_literal(t&nbsp;,&nbsp;u)&nbsp;(either(t&nbsp;,&nbsp;u))either_value<br>#&nbsp;define&nbsp;either_matches(t&nbsp;,&nbsp;e)&nbsp;((e)&nbsp;.&nbsp;type&nbsp;==&nbsp;text_string(t))<br>#&nbsp;define&nbsp;either_as(t&nbsp;,&nbsp;e)&nbsp;((e)&nbsp;.&nbsp;value&nbsp;.&nbsp;text_prefix(as&nbsp;,&nbsp;t))<br>define_either(int&nbsp;,&nbsp;double);<br>static&nbsp;either(int&nbsp;,&nbsp;double)(e1)&nbsp;=&nbsp;either_value(double&nbsp;,&nbsp;3.14);<br>static&nbsp;either(int&nbsp;,&nbsp;double)(e2)&nbsp;=&nbsp;either_value(int&nbsp;,&nbsp;7);<br>void&nbsp;print_either__int__double(either(int&nbsp;,&nbsp;double)&nbsp;const(e)){<br>&nbsp;&nbsp;&nbsp;&nbsp;if(either_matches(int&nbsp;,&nbsp;e)){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%d\n&quot;&nbsp;,&nbsp;either_as(int&nbsp;,&nbsp;e));<br>&nbsp;&nbsp;&nbsp;&nbsp;}else{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%f\n&quot;&nbsp;,&nbsp;either_as(double&nbsp;,&nbsp;e));<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br>int(main(void)){<br>&nbsp;&nbsp;&nbsp;&nbsp;print_either__int__double(e1);<br>&nbsp;&nbsp;&nbsp;&nbsp;print_either__int__double(e2);<br>}</pre>
	<p>With the relevant preprocessing producing:</p>
	<pre class="no-margin padded code">typedef&nbsp;struct{&nbsp;char&nbsp;const(*&nbsp;type);&nbsp;union{&nbsp;int(as__int);&nbsp;double(as__double);&nbsp;}(value);&nbsp;}(either__int__double);<br>static&nbsp;either__int__double(e1)&nbsp;=&nbsp;{&nbsp;.&nbsp;type&nbsp;=&nbsp;&quot;double&quot;&nbsp;,&nbsp;.&nbsp;value&nbsp;=&nbsp;{&nbsp;.&nbsp;as__double&nbsp;=&nbsp;3.14&nbsp;}&nbsp;};<br>static&nbsp;either__int__double(e2)&nbsp;=&nbsp;{&nbsp;.&nbsp;type&nbsp;=&nbsp;&quot;int&quot;&nbsp;,&nbsp;.&nbsp;value&nbsp;=&nbsp;{&nbsp;.&nbsp;as__int&nbsp;=&nbsp;7&nbsp;}&nbsp;};<br>void&nbsp;print_either__int__double(either__int__double&nbsp;const(e)){<br>&nbsp;if(((e)&nbsp;.&nbsp;type&nbsp;==&nbsp;&quot;int&quot;)){<br>&nbsp;&nbsp;printf(&quot;%d\n&quot;&nbsp;,&nbsp;((e)&nbsp;.&nbsp;value&nbsp;.&nbsp;as__int));<br>&nbsp;}else{<br>&nbsp;&nbsp;printf(&quot;%f\n&quot;&nbsp;,&nbsp;((e)&nbsp;.&nbsp;value&nbsp;.&nbsp;as__double));<br>&nbsp;}<br>}<br>int(main(void)){<br>&nbsp;print_either__int__double(e1);<br>&nbsp;print_either__int__double(e2);<br>}</pre>
	<p>This example depends on the following additions to "text.h":</p>
	<pre class="no-margin padded code">#&nbsp;define&nbsp;text_raw_string(t)&nbsp;#&nbsp;t<br>#&nbsp;define&nbsp;text_string(t)&nbsp;text_raw_string(t)</pre>
	<p>After expanding it's argument, <code>text_string</code> converts it's token argument into a string using the stringify <code>#</code> preprocessing operator.</p>
	<p>The <code>either</code> instance stores it's current type as it's string value. Later on, this string can be directly compared to any other stringified type to determine type equality; this works when compilers merge identical string constants to the same address (should be on by default, but explicitly turned on with <code>-fmerge-constants</code>), otherwise the strings can be compared with <code>strcmp</code>. Of course, one can simply use an integer instead to track the type as well.</p>
	<p>The disadvantage of using string constants to track the type of an Either instance is that matching is never constant evaluated, because the address of string literal objects cannot be converted to an integer constant and therefore switch statements cannot be used for matching.</p>
	<p>If enumerations are used to track the type, then the name of the enumeration and it's enumerators must have unique, macro-generated names so as not to cause name collision with other Either instances that happen to contain the same member types. Then matching would require to regenerate those names; resulting in cumbersome code.</p>
	<p>If a plain integer is used to track the type, then there is no problem except that the user will have to remember which integer values correspond to which type of the union.</p>
	<p>Implementing the Variant, which generalizes Either with any number of possible types, is trickier and requires implementing primitive recursion in the preprocessor. This has been done by others and there are online articles on it. I won't cover that in this article.</p>
	<p>So far we have looked at C polymorphism in the form of universal quantification, which are functions from type to term ("polymorphic functions") and functions from type to type ("type constructors"): these are both accomplished using the function macros. Universal quantification implemented this way is good for being "zero-overhead" but requires recompilation when the structure of the input types change.</p>
	<p>Existential quantification is the next kind of polymorphism we will look at for C. I will update this article or make another one to discuss it.</p>
	<!--
	<p>Existential quantification is &exist;T.F(T): which abstractly represents something whose structure is not completely known. More specifically, it is a pair containing some unknown T, together with the application of T over the abstraction F.</p>
	<p>In popular programming languages, this takes the form of many terminologies: "virtual functions", "dynamic dispatch", "dynamic traits", "abstract data types", and "interfaces".</p>
	<p>In C, this is essentially implemented with pointers to functions. The two common ways of implementing existential types are:</p>
	-->
</article>
