<article>
	<header class="top-border">
		<h2>C Polymorphism</h2>
		by Mark Swoope<br>
		<time datetime="2024-07-30">2024-07-30</time>
	</header>
	<p>The C language has advantages in being fast, portable, and small. It's disadvantages include the lack of abstracting over types, which to be fair: no mainstream language really supports beyond the depended type being a constant.</p>
	<p>In this article, I will discuss accomplishing parametric polymorphism in C: the substitution of types into code that abstracts over types.</p>
	<p>Going forward, all other code examples will include this small preprocessing library &quot;token.h&quot;:</p>
	<pre class="no-margin padded code">#&nbsp;ifndef&nbsp;token_h&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;define&nbsp;token_h&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;define&nbsp;token_raw_string(t)&nbsp;#&nbsp;t<br>&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;define&nbsp;token_string(t)&nbsp;token_raw_string(t)<br>&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;define&nbsp;token_raw_prefix(a&nbsp;,&nbsp;b)&nbsp;a&nbsp;##&nbsp;__&nbsp;##&nbsp;b<br>&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;define&nbsp;token_prefix(a&nbsp;,&nbsp;b)&nbsp;token_raw_prefix(a&nbsp;,&nbsp;b)<br>&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;define&nbsp;token_raw_infix(a&nbsp;,&nbsp;b&nbsp;,&nbsp;c)&nbsp;a&nbsp;##&nbsp;__&nbsp;##&nbsp;b&nbsp;##&nbsp;__&nbsp;##&nbsp;c<br>&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;define&nbsp;token_infix(a&nbsp;,&nbsp;b&nbsp;,&nbsp;c)&nbsp;token_raw_infix(a&nbsp;,&nbsp;b&nbsp;,&nbsp;c)<br>&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;define&nbsp;token_if(x)&nbsp;token_prefix(token_if&nbsp;,&nbsp;x)<br>&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;define&nbsp;token_if__1(...)&nbsp;__VA_ARGS__&nbsp;token_else__1<br>&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;define&nbsp;token_else__1(...)<br>&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;define&nbsp;token_if__0(...)&nbsp;token_else__0<br>&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;define&nbsp;token_else__0(...)&nbsp;__VA_ARGS__<br>&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;define&nbsp;token_second(a&nbsp;,&nbsp;b&nbsp;,&nbsp;...)&nbsp;b<br>&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;define&nbsp;token_prove(...)&nbsp;token_second(__VA_ARGS__&nbsp;,&nbsp;0)<br>&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;define&nbsp;token_proof()&nbsp;0&nbsp;,&nbsp;1<br>#&nbsp;endif</pre>
	<p>A polymorphic function maps a type to a term. Applying a type to a polymorphic function results in a monomorphic function: which is just a normal function from term to term.</p>
	<p>This first example uses our token library to define a three-way comparison polymorphic function, we then apply it 3 times to create 3 monomorphic functions:</p>
	<pre class="no-margin padded code">#&nbsp;include&quot;token.h&quot;<br>#&nbsp;define&nbsp;compare(t)&nbsp;token_prefix(compare&nbsp;,&nbsp;t)<br>#&nbsp;define&nbsp;define_compare(t)&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;int(compare(t)(t&nbsp;const(a)&nbsp;,&nbsp;t&nbsp;const(b))){\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(a&nbsp;&lt;&nbsp;b&nbsp;?&nbsp;-&nbsp;1&nbsp;:&nbsp;a&nbsp;&gt;&nbsp;b&nbsp;?&nbsp;1&nbsp;:&nbsp;0);\<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>define_compare(char)<br>define_compare(int)<br>define_compare(double)</pre>


	<p>This preprocesses to:</p>
	<pre class="no-margin padded code">int(compare__char(char&nbsp;const&nbsp;(a),&nbsp;char&nbsp;const&nbsp;(b))){
<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(a&nbsp;&lt;&nbsp;b&nbsp;?&nbsp;-1&nbsp;:&nbsp;a&nbsp;&gt;&nbsp;b&nbsp;?&nbsp;1&nbsp;:&nbsp;0);
<br>}
<br>int(compare__int(int&nbsp;const&nbsp;(a),&nbsp;int&nbsp;const&nbsp;(b))){
<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(a&nbsp;&lt;&nbsp;b&nbsp;?&nbsp;-1&nbsp;:&nbsp;a&nbsp;&gt;&nbsp;b&nbsp;?&nbsp;1&nbsp;:&nbsp;0);
<br>}
<br>int(compare__double(double&nbsp;const&nbsp;(a),&nbsp;double&nbsp;const&nbsp;(b))){
<br>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(a&nbsp;&lt;&nbsp;b&nbsp;?&nbsp;-1&nbsp;:&nbsp;a&nbsp;&gt;&nbsp;b&nbsp;?&nbsp;1&nbsp;:&nbsp;0);
<br>}</pre>
	<p>The function macro <code>define_compare</code> defines a function with a name generated from it's type argument. The name is generated by concatenating the tokens <code>compare</code> with the expansion of <code>t</code>, delimited by <code>__</code>.</p>
	<p>For this to work, the type argument must expands to a single identifier. Therefore, the type <code>long double</code> would not work but the type <code>long_double</code>, a type alias for it, would. Also two types with the same definition but different names would constitute different types; for one type to be an alias for another, an object macro would have to be used.</p>
	<p>It is important for the <code>token_prefix</code> macro to expand and forward it's arguments to <code>token_raw_prefix</code> since the token pasting operator <code>##</code> inhibits expansion of it's direct arguments.</p>
	<p>Unlike in modern languages, monomorphization is not automatic. Each new instance of <code>compare</code> requires a unique expansion of <code>define_compare</code>; and the one-definition rule disallows the same function to be defined more than once.</p>
	<p>The solution to this is to place each instantiation into it's own header file with include guards. Additionally, the header file should itself include any instantiation header files that the polymorphic definition depends on, especially instantiations of other polymorphic functions/types that are instantiated by the same type arguments.</p>
	<p>Often times it is desirable to provide specific instantiations for a limited set of type arguments while providing a generic instantiation for all other types (if at all).</p>
	<p>Let's extend the example by adding specializations for <code>int</code> and strings:</p>
	<pre class="no-margin padded code">#&nbsp;include&quot;token.h&quot;<br>#&nbsp;include&lt;string.h&gt;<br>typedef&nbsp;char&nbsp;const(*&nbsp;string);<br>#&nbsp;define&nbsp;compare_on_string(t)&nbsp;token_prove(token_prefix(compare_on_string&nbsp;,&nbsp;t))<br>#&nbsp;define&nbsp;compare_on_string__string&nbsp;token_proof()<br>#&nbsp;define&nbsp;compare_on_int(t)&nbsp;token_prove(token_prefix(compare_on_int&nbsp;,&nbsp;t))<br>#&nbsp;define&nbsp;compare_on_int__int&nbsp;token_proof()<br>#&nbsp;define&nbsp;compare(t)&nbsp;token_prefix(compare&nbsp;,&nbsp;t)<br>#&nbsp;define&nbsp;define_compare(t)&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;int(compare(t)(t&nbsp;const(a)&nbsp;,&nbsp;t&nbsp;const(b))){\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token_if(compare_on_string(t))(\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strcmp(a&nbsp;,&nbsp;b)\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)(\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token_if(compare_on_int(t))(\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;-&nbsp;b\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)(\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;&lt;&nbsp;b&nbsp;?&nbsp;-&nbsp;1&nbsp;:&nbsp;a&nbsp;&gt;&nbsp;b&nbsp;?&nbsp;1&nbsp;:&nbsp;0\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);\<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>define_compare(char)<br>define_compare(int)<br>define_compare(double)<br>define_compare(string)</pre>
	<p>The preprocessing result:</p>
	<pre class="no-margin padded code">typedef&nbsp;char&nbsp;const(*&nbsp;string);<br>int(compare__char(char&nbsp;const(a)&nbsp;,&nbsp;char&nbsp;const(b))){<br>&nbsp;&nbsp;&nbsp;&nbsp;return(a&nbsp;&lt;&nbsp;b&nbsp;?&nbsp;-&nbsp;1&nbsp;:&nbsp;a&nbsp;&gt;&nbsp;b&nbsp;?&nbsp;1&nbsp;:&nbsp;0);<br>}<br>int(compare__int(int&nbsp;const(a)&nbsp;,&nbsp;int&nbsp;const(b))){return(&nbsp;a&nbsp;-&nbsp;b&nbsp;);}<br>int(compare__double(double&nbsp;const(a)&nbsp;,&nbsp;double&nbsp;const(b))){<br>&nbsp;&nbsp;&nbsp;&nbsp;return(a&nbsp;&lt;&nbsp;b&nbsp;?&nbsp;-&nbsp;1&nbsp;:&nbsp;a&nbsp;&gt;&nbsp;b&nbsp;?&nbsp;1&nbsp;:&nbsp;0);<br>}<br>int(compare__string(string&nbsp;const(a)&nbsp;,&nbsp;string&nbsp;const(b))){<br>&nbsp;&nbsp;&nbsp;&nbsp;return(strcmp(a&nbsp;,&nbsp;b));<br>}</pre>
	<p>The macro <code>token_if</code> expands to it's 2nd or 3rd application's tokens depending on if it's first application expands to 1 or 0.</p>
	<p><code>compare_on_int</code> (string) expands to 1 if it's argument is <code>int</code> (string). It works by using <code>token_prove</code> which expands to 1 only if it's single argument is the expansion of <code>token_proof()</code>. By having an object macro , whose name contains the type we are matching against, expand to <code>token_proof()</code>, and by using <code>token_prefix</code> to attempt to construct that name and sending it to <code>token_prove</code>, we can match against any specific token.</p>
	<p>These same methods can be used for creating type constructors in C: mappings from type to type. This can be how an array container, supporting both dynamic and fixed lengths, can be defined:</p>
	<pre class="no-margin padded code">#&nbsp;include&quot;token.h&quot;<br>#&nbsp;define&nbsp;array_size_on_auto(n)&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;token_prove(token_prefix(array_size_on_auto&nbsp;,&nbsp;n))<br>#&nbsp;define&nbsp;array_size_on_auto__auto&nbsp;token_proof()<br>#&nbsp;define&nbsp;array(t&nbsp;,&nbsp;n)&nbsp;token_infix(array&nbsp;,&nbsp;t&nbsp;,&nbsp;n)<br>#&nbsp;define&nbsp;define_array(t&nbsp;,&nbsp;n)&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;struct{\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;token_if(array_size_on_auto(n))(\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size_t(size);\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t(data[])\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)(\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t(data[n])\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);\<br>&nbsp;&nbsp;&nbsp;&nbsp;}(array(t&nbsp;,&nbsp;n))<br>define_array(float&nbsp;,&nbsp;3);<br>define_array(char&nbsp;,&nbsp;auto);</pre>
	<p>Which preprocesses to:</p>
	<pre class="no-margin padded code">typedef&nbsp;struct{float(data[3]);}(array__float__3);<br>typedef&nbsp;struct{size_t(size);&nbsp;char(data[]);}(array__char__auto);</pre>
	<p>The keyword <code>auto</code> is chosen to indicate a dynamic array which can only exist in dynamic storage, any other value for the 2nd argument is assumed to be an integer constant for it's fixed length.</p>
	<p>Here is an example for an Either kind, the type constructor for a tagged union of two types:</p>
	<pre class="no-margin padded code">#&nbsp;include&quot;token.h&quot;<br>#&nbsp;include&lt;stdbool.h&gt;<br>#&nbsp;define&nbsp;either(t&nbsp;,&nbsp;u)&nbsp;token_infix(either&nbsp;,&nbsp;t&nbsp;,&nbsp;u)<br>#&nbsp;define&nbsp;define_either(t&nbsp;,&nbsp;u)&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;struct{\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bool(index);\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;union{\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t(at__0);\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u(at__1);\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}(value);\<br>&nbsp;&nbsp;&nbsp;&nbsp;}(either(t&nbsp;,&nbsp;u))<br>#&nbsp;define&nbsp;either_initializer(i&nbsp;,&nbsp;...)&nbsp;{\<br>&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp;index&nbsp;=&nbsp;i\<br>&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;.&nbsp;value&nbsp;=&nbsp;{.&nbsp;token_prefix(at&nbsp;,&nbsp;i)&nbsp;=&nbsp;__VA_ARGS__}\<br>}<br>#&nbsp;define&nbsp;either_at(i&nbsp;,&nbsp;e)&nbsp;((e)&nbsp;.&nbsp;value&nbsp;.&nbsp;token_prefix(at&nbsp;,&nbsp;i))</pre>
	<p>This uses <code>bool</code> to track it's current type in the <code>index</code> field.</p>
	<p><code>either_initializer</code> can initialize any instance of <code>either</code> given a decimal integer constant of it's index and the rest of the arguments used to initialize the proper union field.</p>
	<p><code>either_at</code> accesses the inner union field of an either instance given it's decimal integer constant index.</p>
	<p>Matching tagged unions by index, while not as ergonomic as being able to match against type names, is efficient and tolerable for only two possible types.</p>
	<p>It is possible to redesign either to match against type names. This can be done by having the tag store the address of a string constant whose contents is the type name. Using <code>token_string</code> to stringify type names and turning on <code>-fmerge-constants</code>, allows us to build an either that matches against types at the cost of a simple pointer comparison:</p>
	<pre class="no-margin padded code">#&nbsp;include&quot;token.h&quot;<br>#&nbsp;define&nbsp;either(t&nbsp;,&nbsp;u)&nbsp;token_infix(either&nbsp;,&nbsp;t&nbsp;,&nbsp;u)<br>#&nbsp;define&nbsp;define_either(t&nbsp;,&nbsp;u)&nbsp;\<br>&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;struct{\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;const((*&nbsp;type)[]);\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;union{\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t(token_prefix(as&nbsp;,&nbsp;t));\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u(token_prefix(as&nbsp;,&nbsp;u));\<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}(value);\<br>&nbsp;&nbsp;&nbsp;&nbsp;}(either(t&nbsp;,&nbsp;u))<br>#&nbsp;define&nbsp;either_initializer(t&nbsp;,&nbsp;...)&nbsp;{\<br>&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp;type&nbsp;=&nbsp;&amp;(token_string(t))\<br>&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;.&nbsp;value&nbsp;=&nbsp;{.&nbsp;token_prefix(as&nbsp;,&nbsp;t)&nbsp;=&nbsp;__VA_ARGS__}\<br>}<br>#&nbsp;define&nbsp;either_is(t&nbsp;,&nbsp;e)&nbsp;((e)&nbsp;.&nbsp;type&nbsp;==&nbsp;&amp;(token_string(t)))<br>#&nbsp;define&nbsp;either_as(t&nbsp;,&nbsp;e)&nbsp;((e)&nbsp;.&nbsp;value&nbsp;.&nbsp;token_prefix(as&nbsp;,&nbsp;t))</pre>
	<p>The disadvantage of this approach is that you cannot use a <code>switch</code> statement to perform matching, this is because <code>switch</code> can only compare over integer constants and the address of a string constant, even if it's an address constant expression, cannot be converted into an integer constant expression by the rules of the language. We are also depending on a compiler optimization that may have to be turned on explicitly for efficient type comparison, otherwise we can fall back to using <code>strcmp</code> for less-efficiency but more portability.</p>
	<p>Using an enumeration to track the type of a tagged union requires the names of the enumeration and it's enumerators to be unique across the entire translation unit, this is because enumerations do not establish scope and instead pollute the global name space with all it's enumerators.</p>
	<p>A type constructor for a tagged union that uses enumerations, requires name generation using token pasting from the all the input types. Performing any object operation of an instantiation would require user specification of all the types of that instantiation. I conclude that enumerations are a bad idea for tagged union type constructor tags in C.</p>
	<p>The variant, which generalizes either with an arbitrary number of possible types, requires implementing primitive recursion in the preprocessor which can be done but will not be covered in this article.</p>
	<p>The conclusion here is: parametric polymorphism is possible in C using the preprocessor, we can also perform type-dependent name generation using token pasting, we can perform specialization over explicit types using a technique for token matching, and type names can be stored and queried at run-time using stringification.</p>
	<p>Monomorphization needs to be performed manually, with each monomorphic function (and it's dependencies) preferrably placed in it's own include-guarded header file for large projects.</p>
</article>

