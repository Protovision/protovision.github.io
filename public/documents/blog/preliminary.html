<header>
	<h2>Preliminary</h2>
	<time datetime="2022-09-01">2022-09-01</time>
</header>
<p>I have decided to remake this website. As of the date of this writing, this 
is a single page application that requires JavaScript. Each logical page
includes important links at the top which include: my email address, LinkedIn 
profile, Github profile, and a link to the index of this blog. The main page 
is my About page. The paper design is neutral and non-offensive to the tastes 
of whoever visits this site and it accurately portrays what the content will 
look like when printed.</p>
<p>My writing shall now be more visible to the public since this is hosted 
on my main Github page (protovision.github.io) whereas previously it was only
my resume hosted here. I will try to write more on computer science topics to 
hopefully demonstrate my knowledge to owners of capital but also mainly to 
motivate myself in my own work when I find the time off from labor.</p>
<p>My main project which I hope to finish is a programming language that will
absolutely not be yet another C clone with tacked-on features that introduce 
hidden control flow and storage overhead. It will be a static and strongly 
typed language with low-level features but it will also enable you to organize 
your code and data so that control flow and mutation become visible and 
manageable. Syntactically, it will be homoiconic and not look like the syntax 
of C or any other language. Hopefully it will have good metaprogramming 
support. The main paradigm will be imperative, but also highly structured; 
there will be no support for object-oriented, functional, or declarative 
styles. The initial compilation targets might be: C, Lua, JavaScript, and 
WebAssembly.</p>
<p>During my research on programming languages and type theory, I have learned 
to appreciate the idea of a strongly-normalizing language as well as the common
wisdom of minimizing global mutable state taken from the functional style. 
Linear type systems based on linear logic are also very fascinating but seem to
be open to competing interpretations and research. I have learned about the 
lambda calculi and how they fit within the lambda cube. The Y-combinator seems
to be the one mechanism that separates mainstream general-purpose programming 
languages from the strongly-normalizing proof checking languages. I believe I 
understand monads: they seem to be the smallest unit of what a complete 
program is (a functional core with an imperative shell) and they can be linked 
together to compose larger programs. Needless to say, I am acquainted with 
algebraic data types and how they can go through catamorphisms and 
anamorphisms. Despite all of this, I am still choosing to make an imperative
language for my first programming language so as not to be overambitious.</p>

